// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_INCLUDED_message_2eproto
#define PROTOBUF_INCLUDED_message_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_message_2eproto 

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_message_2eproto
class LoginReq;
class LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class LoginRsp;
class LoginRspDefaultTypeInternal;
extern LoginRspDefaultTypeInternal _LoginRsp_default_instance_;
class MsgHeader;
class MsgHeaderDefaultTypeInternal;
extern MsgHeaderDefaultTypeInternal _MsgHeader_default_instance_;
class RegEeq;
class RegEeqDefaultTypeInternal;
extern RegEeqDefaultTypeInternal _RegEeq_default_instance_;
class RegRsp;
class RegRspDefaultTypeInternal;
extern RegRspDefaultTypeInternal _RegRsp_default_instance_;
namespace google {
namespace protobuf {
template<> ::LoginReq* Arena::CreateMaybeMessage<::LoginReq>(Arena*);
template<> ::LoginRsp* Arena::CreateMaybeMessage<::LoginRsp>(Arena*);
template<> ::MsgHeader* Arena::CreateMaybeMessage<::MsgHeader>(Arena*);
template<> ::RegEeq* Arena::CreateMaybeMessage<::RegEeq>(Arena*);
template<> ::RegRsp* Arena::CreateMaybeMessage<::RegRsp>(Arena*);
}  // namespace protobuf
}  // namespace google

enum MsgHeader_MsgYype {
  MsgHeader_MsgYype_RegReq = 0,
  MsgHeader_MsgYype_RegRsp = 1,
  MsgHeader_MsgYype_LoginReq = 2,
  MsgHeader_MsgYype_LoginRsp = 3,
  MsgHeader_MsgYype_LogoutReq = 4,
  MsgHeader_MsgYype_LogoutRsp = 5,
  MsgHeader_MsgYype_AddFriendReq = 6,
  MsgHeader_MsgYype_AddFriendRsp = 7,
  MsgHeader_MsgYype_DelFriendReq = 8,
  MsgHeader_MsgYype_DelFriendRsp = 9,
  MsgHeader_MsgYype_PublishMessageReq = 10,
  MsgHeader_MsgYype_PubilishMessageRsp = 11,
  MsgHeader_MsgYype_MsgHeader_MsgYype_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MsgHeader_MsgYype_MsgHeader_MsgYype_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MsgHeader_MsgYype_IsValid(int value);
const MsgHeader_MsgYype MsgHeader_MsgYype_MsgYype_MIN = MsgHeader_MsgYype_RegReq;
const MsgHeader_MsgYype MsgHeader_MsgYype_MsgYype_MAX = MsgHeader_MsgYype_PubilishMessageRsp;
const int MsgHeader_MsgYype_MsgYype_ARRAYSIZE = MsgHeader_MsgYype_MsgYype_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgHeader_MsgYype_descriptor();
inline const ::std::string& MsgHeader_MsgYype_Name(MsgHeader_MsgYype value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgHeader_MsgYype_descriptor(), value);
}
inline bool MsgHeader_MsgYype_Parse(
    const ::std::string& name, MsgHeader_MsgYype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgHeader_MsgYype>(
    MsgHeader_MsgYype_descriptor(), name, value);
}
// ===================================================================

class MsgHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MsgHeader) */ {
 public:
  MsgHeader();
  virtual ~MsgHeader();

  MsgHeader(const MsgHeader& from);

  inline MsgHeader& operator=(const MsgHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgHeader(MsgHeader&& from) noexcept
    : MsgHeader() {
    *this = ::std::move(from);
  }

  inline MsgHeader& operator=(MsgHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgHeader* internal_default_instance() {
    return reinterpret_cast<const MsgHeader*>(
               &_MsgHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MsgHeader* other);
  friend void swap(MsgHeader& a, MsgHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgHeader* New() const final {
    return CreateMaybeMessage<MsgHeader>(NULL);
  }

  MsgHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MsgHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MsgHeader& from);
  void MergeFrom(const MsgHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MsgHeader_MsgYype MsgYype;
  static const MsgYype RegReq =
    MsgHeader_MsgYype_RegReq;
  static const MsgYype RegRsp =
    MsgHeader_MsgYype_RegRsp;
  static const MsgYype LoginReq =
    MsgHeader_MsgYype_LoginReq;
  static const MsgYype LoginRsp =
    MsgHeader_MsgYype_LoginRsp;
  static const MsgYype LogoutReq =
    MsgHeader_MsgYype_LogoutReq;
  static const MsgYype LogoutRsp =
    MsgHeader_MsgYype_LogoutRsp;
  static const MsgYype AddFriendReq =
    MsgHeader_MsgYype_AddFriendReq;
  static const MsgYype AddFriendRsp =
    MsgHeader_MsgYype_AddFriendRsp;
  static const MsgYype DelFriendReq =
    MsgHeader_MsgYype_DelFriendReq;
  static const MsgYype DelFriendRsp =
    MsgHeader_MsgYype_DelFriendRsp;
  static const MsgYype PublishMessageReq =
    MsgHeader_MsgYype_PublishMessageReq;
  static const MsgYype PubilishMessageRsp =
    MsgHeader_MsgYype_PubilishMessageRsp;
  static inline bool MsgYype_IsValid(int value) {
    return MsgHeader_MsgYype_IsValid(value);
  }
  static const MsgYype MsgYype_MIN =
    MsgHeader_MsgYype_MsgYype_MIN;
  static const MsgYype MsgYype_MAX =
    MsgHeader_MsgYype_MsgYype_MAX;
  static const int MsgYype_ARRAYSIZE =
    MsgHeader_MsgYype_MsgYype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgYype_descriptor() {
    return MsgHeader_MsgYype_descriptor();
  }
  static inline const ::std::string& MsgYype_Name(MsgYype value) {
    return MsgHeader_MsgYype_Name(value);
  }
  static inline bool MsgYype_Parse(const ::std::string& name,
      MsgYype* value) {
    return MsgHeader_MsgYype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // .MsgHeader.MsgYype type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::MsgHeader_MsgYype type() const;
  void set_type(::MsgHeader_MsgYype value);

  // @@protoc_insertion_point(class_scope:MsgHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 version_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegEeq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RegEeq) */ {
 public:
  RegEeq();
  virtual ~RegEeq();

  RegEeq(const RegEeq& from);

  inline RegEeq& operator=(const RegEeq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegEeq(RegEeq&& from) noexcept
    : RegEeq() {
    *this = ::std::move(from);
  }

  inline RegEeq& operator=(RegEeq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegEeq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegEeq* internal_default_instance() {
    return reinterpret_cast<const RegEeq*>(
               &_RegEeq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RegEeq* other);
  friend void swap(RegEeq& a, RegEeq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegEeq* New() const final {
    return CreateMaybeMessage<RegEeq>(NULL);
  }

  RegEeq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegEeq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegEeq& from);
  void MergeFrom(const RegEeq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegEeq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_name = 2;
  void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  const ::std::string& user_name() const;
  void set_user_name(const ::std::string& value);
  #if LANG_CXX11
  void set_user_name(::std::string&& value);
  #endif
  void set_user_name(const char* value);
  void set_user_name(const char* value, size_t size);
  ::std::string* mutable_user_name();
  ::std::string* release_user_name();
  void set_allocated_user_name(::std::string* user_name);

  // string password = 3;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // .MsgHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::MsgHeader& _internal_header() const;
  public:
  const ::MsgHeader& header() const;
  ::MsgHeader* release_header();
  ::MsgHeader* mutable_header();
  void set_allocated_header(::MsgHeader* header);

  // uint32 from = 4;
  void clear_from();
  static const int kFromFieldNumber = 4;
  ::google::protobuf::uint32 from() const;
  void set_from(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RegEeq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::MsgHeader* header_;
  ::google::protobuf::uint32 from_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RegRsp) */ {
 public:
  RegRsp();
  virtual ~RegRsp();

  RegRsp(const RegRsp& from);

  inline RegRsp& operator=(const RegRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegRsp(RegRsp&& from) noexcept
    : RegRsp() {
    *this = ::std::move(from);
  }

  inline RegRsp& operator=(RegRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegRsp* internal_default_instance() {
    return reinterpret_cast<const RegRsp*>(
               &_RegRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RegRsp* other);
  friend void swap(RegRsp& a, RegRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegRsp* New() const final {
    return CreateMaybeMessage<RegRsp>(NULL);
  }

  RegRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegRsp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegRsp& from);
  void MergeFrom(const RegRsp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .MsgHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::MsgHeader& _internal_header() const;
  public:
  const ::MsgHeader& header() const;
  ::MsgHeader* release_header();
  ::MsgHeader* mutable_header();
  void set_allocated_header(::MsgHeader* header);

  // uint32 ret = 2;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::google::protobuf::uint32 ret() const;
  void set_ret(::google::protobuf::uint32 value);

  // uint32 user_id = 3;
  void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RegRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::MsgHeader* header_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 user_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LoginReq) */ {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LoginReq* other);
  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginReq* New() const final {
    return CreateMaybeMessage<LoginReq>(NULL);
  }

  LoginReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_name = 1;
  void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& user_name() const;
  void set_user_name(const ::std::string& value);
  #if LANG_CXX11
  void set_user_name(::std::string&& value);
  #endif
  void set_user_name(const char* value);
  void set_user_name(const char* value, size_t size);
  ::std::string* mutable_user_name();
  ::std::string* release_user_name();
  void set_allocated_user_name(::std::string* user_name);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:LoginReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LoginRsp) */ {
 public:
  LoginRsp();
  virtual ~LoginRsp();

  LoginRsp(const LoginRsp& from);

  inline LoginRsp& operator=(const LoginRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRsp(LoginRsp&& from) noexcept
    : LoginRsp() {
    *this = ::std::move(from);
  }

  inline LoginRsp& operator=(LoginRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRsp* internal_default_instance() {
    return reinterpret_cast<const LoginRsp*>(
               &_LoginRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(LoginRsp* other);
  friend void swap(LoginRsp& a, LoginRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRsp* New() const final {
    return CreateMaybeMessage<LoginRsp>(NULL);
  }

  LoginRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginRsp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginRsp& from);
  void MergeFrom(const LoginRsp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_id = 2;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // uint32 ret = 1;
  void clear_ret();
  static const int kRetFieldNumber = 1;
  ::google::protobuf::uint32 ret() const;
  void set_ret(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:LoginRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::uint32 ret_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgHeader

// int32 version = 1;
inline void MsgHeader::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 MsgHeader::version() const {
  // @@protoc_insertion_point(field_get:MsgHeader.version)
  return version_;
}
inline void MsgHeader::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:MsgHeader.version)
}

// .MsgHeader.MsgYype type = 2;
inline void MsgHeader::clear_type() {
  type_ = 0;
}
inline ::MsgHeader_MsgYype MsgHeader::type() const {
  // @@protoc_insertion_point(field_get:MsgHeader.type)
  return static_cast< ::MsgHeader_MsgYype >(type_);
}
inline void MsgHeader::set_type(::MsgHeader_MsgYype value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:MsgHeader.type)
}

// -------------------------------------------------------------------

// RegEeq

// .MsgHeader header = 1;
inline bool RegEeq::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RegEeq::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::MsgHeader& RegEeq::_internal_header() const {
  return *header_;
}
inline const ::MsgHeader& RegEeq::header() const {
  const ::MsgHeader* p = header_;
  // @@protoc_insertion_point(field_get:RegEeq.header)
  return p != NULL ? *p : *reinterpret_cast<const ::MsgHeader*>(
      &::_MsgHeader_default_instance_);
}
inline ::MsgHeader* RegEeq::release_header() {
  // @@protoc_insertion_point(field_release:RegEeq.header)
  
  ::MsgHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::MsgHeader* RegEeq::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::MsgHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RegEeq.header)
  return header_;
}
inline void RegEeq::set_allocated_header(::MsgHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:RegEeq.header)
}

// string user_name = 2;
inline void RegEeq::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegEeq::user_name() const {
  // @@protoc_insertion_point(field_get:RegEeq.user_name)
  return user_name_.GetNoArena();
}
inline void RegEeq::set_user_name(const ::std::string& value) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegEeq.user_name)
}
#if LANG_CXX11
inline void RegEeq::set_user_name(::std::string&& value) {
  
  user_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegEeq.user_name)
}
#endif
inline void RegEeq::set_user_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegEeq.user_name)
}
inline void RegEeq::set_user_name(const char* value, size_t size) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegEeq.user_name)
}
inline ::std::string* RegEeq::mutable_user_name() {
  
  // @@protoc_insertion_point(field_mutable:RegEeq.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEeq::release_user_name() {
  // @@protoc_insertion_point(field_release:RegEeq.user_name)
  
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEeq::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    
  } else {
    
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:RegEeq.user_name)
}

// string password = 3;
inline void RegEeq::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegEeq::password() const {
  // @@protoc_insertion_point(field_get:RegEeq.password)
  return password_.GetNoArena();
}
inline void RegEeq::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegEeq.password)
}
#if LANG_CXX11
inline void RegEeq::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegEeq.password)
}
#endif
inline void RegEeq::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegEeq.password)
}
inline void RegEeq::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegEeq.password)
}
inline ::std::string* RegEeq::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:RegEeq.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEeq::release_password() {
  // @@protoc_insertion_point(field_release:RegEeq.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEeq::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:RegEeq.password)
}

// uint32 from = 4;
inline void RegEeq::clear_from() {
  from_ = 0u;
}
inline ::google::protobuf::uint32 RegEeq::from() const {
  // @@protoc_insertion_point(field_get:RegEeq.from)
  return from_;
}
inline void RegEeq::set_from(::google::protobuf::uint32 value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:RegEeq.from)
}

// -------------------------------------------------------------------

// RegRsp

// .MsgHeader header = 1;
inline bool RegRsp::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RegRsp::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::MsgHeader& RegRsp::_internal_header() const {
  return *header_;
}
inline const ::MsgHeader& RegRsp::header() const {
  const ::MsgHeader* p = header_;
  // @@protoc_insertion_point(field_get:RegRsp.header)
  return p != NULL ? *p : *reinterpret_cast<const ::MsgHeader*>(
      &::_MsgHeader_default_instance_);
}
inline ::MsgHeader* RegRsp::release_header() {
  // @@protoc_insertion_point(field_release:RegRsp.header)
  
  ::MsgHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::MsgHeader* RegRsp::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::MsgHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RegRsp.header)
  return header_;
}
inline void RegRsp::set_allocated_header(::MsgHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:RegRsp.header)
}

// uint32 ret = 2;
inline void RegRsp::clear_ret() {
  ret_ = 0u;
}
inline ::google::protobuf::uint32 RegRsp::ret() const {
  // @@protoc_insertion_point(field_get:RegRsp.ret)
  return ret_;
}
inline void RegRsp::set_ret(::google::protobuf::uint32 value) {
  
  ret_ = value;
  // @@protoc_insertion_point(field_set:RegRsp.ret)
}

// uint32 user_id = 3;
inline void RegRsp::clear_user_id() {
  user_id_ = 0u;
}
inline ::google::protobuf::uint32 RegRsp::user_id() const {
  // @@protoc_insertion_point(field_get:RegRsp.user_id)
  return user_id_;
}
inline void RegRsp::set_user_id(::google::protobuf::uint32 value) {
  
  user_id_ = value;
  // @@protoc_insertion_point(field_set:RegRsp.user_id)
}

// -------------------------------------------------------------------

// LoginReq

// string user_name = 1;
inline void LoginReq::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginReq::user_name() const {
  // @@protoc_insertion_point(field_get:LoginReq.user_name)
  return user_name_.GetNoArena();
}
inline void LoginReq::set_user_name(const ::std::string& value) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginReq.user_name)
}
#if LANG_CXX11
inline void LoginReq::set_user_name(::std::string&& value) {
  
  user_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginReq.user_name)
}
#endif
inline void LoginReq::set_user_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginReq.user_name)
}
inline void LoginReq::set_user_name(const char* value, size_t size) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginReq.user_name)
}
inline ::std::string* LoginReq::mutable_user_name() {
  
  // @@protoc_insertion_point(field_mutable:LoginReq.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReq::release_user_name() {
  // @@protoc_insertion_point(field_release:LoginReq.user_name)
  
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    
  } else {
    
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:LoginReq.user_name)
}

// string password = 2;
inline void LoginReq::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginReq::password() const {
  // @@protoc_insertion_point(field_get:LoginReq.password)
  return password_.GetNoArena();
}
inline void LoginReq::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginReq.password)
}
#if LANG_CXX11
inline void LoginReq::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginReq.password)
}
#endif
inline void LoginReq::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginReq.password)
}
inline void LoginReq::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginReq.password)
}
inline ::std::string* LoginReq::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:LoginReq.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReq::release_password() {
  // @@protoc_insertion_point(field_release:LoginReq.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:LoginReq.password)
}

// -------------------------------------------------------------------

// LoginRsp

// uint32 ret = 1;
inline void LoginRsp::clear_ret() {
  ret_ = 0u;
}
inline ::google::protobuf::uint32 LoginRsp::ret() const {
  // @@protoc_insertion_point(field_get:LoginRsp.ret)
  return ret_;
}
inline void LoginRsp::set_ret(::google::protobuf::uint32 value) {
  
  ret_ = value;
  // @@protoc_insertion_point(field_set:LoginRsp.ret)
}

// string user_id = 2;
inline void LoginRsp::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRsp::user_id() const {
  // @@protoc_insertion_point(field_get:LoginRsp.user_id)
  return user_id_.GetNoArena();
}
inline void LoginRsp::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRsp.user_id)
}
#if LANG_CXX11
inline void LoginRsp::set_user_id(::std::string&& value) {
  
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRsp.user_id)
}
#endif
inline void LoginRsp::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRsp.user_id)
}
inline void LoginRsp::set_user_id(const char* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRsp.user_id)
}
inline ::std::string* LoginRsp::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:LoginRsp.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRsp::release_user_id() {
  // @@protoc_insertion_point(field_release:LoginRsp.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRsp::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:LoginRsp.user_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MsgHeader_MsgYype> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgHeader_MsgYype>() {
  return ::MsgHeader_MsgYype_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_message_2eproto
